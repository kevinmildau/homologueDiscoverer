cat.dist = c(0.055, 0.055, 0.1, 0.1,0.1))
plotNontarget <- function(annotated_peak_table) {
#require(Cairo)   # For nicer ggplot2 output when deployed on Linux
annotated_peak_table <- mutate(annotated_peak_table,
polymer_id = if_else(is.na(polymer_id), 0L, polymer_id),
polymer_id = as.factor(polymer_id),
n_assignments = as.factor(n_assignments))
if (length(unique(annotated_peak_table$polymer_id)) > 100) {
legend_setting = "none"
} else {
legend_setting = "right"
}
colourCount = length(unique(annotated_peak_table$polymer_id))
getPalette = colorRampPalette(RColorBrewer::brewer.pal(9, "Set1"))
ncolor = length(unique(annotated_peak_table$polymer_id))
nassignments <- length(unique(annotated_peak_table$n_assignments))
annotated_peak_table <- arrange(annotated_peak_table, desc(polymer_id))
ui <- fluidPage(
plotOutput("plot", width = '100%', height = 1200,
dblclick = dblclickOpts("plot_dblclick"),
brush = brushOpts(
id = "plot_brush",
resetOnNew = TRUE)),
tableOutput("annotated_peak_table")
)
server <- function(input, output) {
ranges <- reactiveValues(x = NULL, y = NULL) # Null defaults
output$plot <- renderPlot({
ggplot(annotated_peak_table, aes(group = polymer_id)) +
geom_point(aes(x = rt, y = mz, color = n_assignments, size = polymer_id,
shape = n_assignments, alpha = n_assignments)) +
geom_line(data = filter(annotated_peak_table, polymer_id != 0),
aes(x = rt, y = mz, group = polymer_id), alpha = 0.5) +
ggtitle("Peak Table") +
scale_colour_manual(values = c("grey20", rep("red", times = nassignments))) +
scale_size_manual(values = c(0.1, rep(4, times = ncolor))) +
scale_shape_manual(values = c(19, rep(17, times = nassignments) )) +
scale_alpha_manual(values = c(0.1, rep(1, times = nassignments))) +
coord_cartesian(xlim = ranges$x, ylim = ranges$y, expand = FALSE) +
theme(legend.position=legend_setting)
})
# When a double-click happens, check if there's a brush on the plot.
# If so, zoom to the brush bounds; if not, reset the zoom.
observeEvent(input$plot_dblclick, {
brush <- input$plot_brush
if (!is.null(brush)) {
ranges$x <- c(brush$xmin, brush$xmax)
ranges$y <- c(brush$ymin, brush$ymax)
} else {
ranges$x <- NULL
ranges$y <- NULL
}
})
output$annotated_peak_table <- renderTable({
brushedPoints(annotated_peak_table, input$plot_brush)
})
}
shinyApp(ui, server)
}
createPseudoPeakTableFromNonTarget <- function(nontarget_out){
peak_table <- as_tibble(nontarget_out$`Peaks in homologue series`)
names(peak_table) <- stringr::str_replace_all(names(peak_table), " |/", "_")
all(peak_table$HS_IDs == peak_table$HS_cluster)
# unnesting creates duplicate rows immediately! So for each peak with n series assignments, there will now be n rows.
peak_table <- peak_table %>%
mutate(., series_ids = str_split(HS_cluster, pattern = "/")) %>%
unnest(., series_ids)
peak_table <- peak_table %>%
rename(., mz = mz, rt = RT, polymer_id = series_ids, nontarget_peak_id = peak_ID) %>%
mutate(., polymer_id = as.integer(polymer_id), nontarget_peak_id = as.integer(nontarget_peak_id)) %>%
mutate(., polymer_id = if_else(polymer_id == 0, as.integer(NA), polymer_id)) %>%
select(., mz, rt, polymer_id, nontarget_peak_id, intensity)
peak_table <- peak_table %>%
arrange(., mz, rt) %>%
group_by(., polymer_id) %>%
mutate(., within_series_id = row_number()) %>%
mutate(., within_series_id = if_else(polymer_id == 0L, as.integer(NA), within_series_id)) %>%
ungroup(.)
peak_table <- peak_table %>%
group_by(., nontarget_peak_id) %>%
add_tally(name = "n_assignments") %>%
ungroup(.)
return (peak_table)
}
display_venn <- function(x, ...){
library(VennDiagram)
grid.newpage()
venn_object <- venn.diagram(x, filename = NULL, ..., disable.logging = TRUE)
grid.draw(venn_object)
}
createSeriesStrings <- function(out){
summary <- out %>%
na.omit(.) %>%
group_by(polymer_id) %>%
arrange(., peak_id) %>%
summarize(., series_string = paste(peak_id, collapse = "-->"))
strings <- pull(summary, series_string)
return(strings)
}
createAnnotedPeakIdList<- function(out){
ids <- out %>%
na.omit(.) %>%
pull(peak_id) %>%
unique(.)
return(ids)
}
# This plot represents the effect on annotated peaks of only chaning rttol in nontarget
display_venn(list(rsidentifier = createAnnotedPeakIdList(outrs01),
rttol_50 = createAnnotedPeakIdList(outnt01_ptb),
default_nontarget = createAnnotedPeakIdList(outnt02_ptb),
rttol_1 = createAnnotedPeakIdList(outnt04_ptb),
rt_tol_5 = createAnnotedPeakIdList(outnt05_ptb)),
# Circles
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999", "#E69F00", "#56B4E9", "#009E73"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "outer",
cat.dist = c(0.055, 0.055, 0.1, 0.1,0.1))
nass <- outnt01_ptb %>% select(., peak_id, n_assignments) %>% unique() %>% pull(n_assignments)
hist(nass)
nass <- outnt04_ptb %>% select(., peak_id, n_assignments) %>% unique() %>% pull(n_assignments)
hist(nass)
nass <- outnt05_ptb %>% select(., peak_id, n_assignments) %>% unique() %>% pull(n_assignments)
hist(nass)
# Narrow rttol give no overlapping series
nass <- outnt02_ptb %>% select(., peak_id, n_assignments) %>% unique() %>% pull(n_assignments)
hist(nass)
nass <- outnt03_ptb %>% select(., peak_id, n_assignments) %>% unique() %>% pull(n_assignments)
hist(nass)
x <- list(
rsidentifier = rs_strings,
nontarget = nt_strings
)
display_venn(x)
display_venn(x)
ggsave("test-venn.pdf", device = "pdf", width = 10, height = 6, units = "cm", dpi = 300)
?pdf
pdf("test-venn.pdf", width = 6, height = 4)
display_venn(x)
dev.off()
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "outer",
cat.dist = c(0.055, 0.055))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "outer",
cat.dist = c(0.055, 0.2))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "outer",
cat.dist = c(0.1, 0.1))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.1, 0.1))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.1, 0.05))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
pdf("test-venn.pdf", width = 6, height = 4)
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "italic",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
dev.off()
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
fontface = "sans",
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
# Set names
cat.cex = 1,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = .9,
# Set names
cat.cex = 2,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = 1.5,
# Set names
cat.cex = 1.5,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
pdf("test-venn.pdf", width = 6, height = 4)
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = 1.5,
# Set names
cat.cex = 1.5,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
dev.off()
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = 1.5,
# Set names
cat.cex = 1.5,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
pdf("test-venn.pdf", width = 3, height = 2)
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = 1.5,
# Set names
cat.cex = 1.5,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
dev.off()
pdf("test-venn.pdf", width = 6, height = 4)
display_venn(x,
lwd = 2,
lty = 'blank',
fill = c("#FF00FF", "#999999"),
# Numbers
cex = 1.5,
# Set names
cat.cex = 1.5,
cat.fontface = "bold",
cat.default.pos = "text",
cat.dist = c(0.05, 0.05))
dev.off()
library(devtools)
load_all()
document()
document()
load_all()
load_all()
# Load minimal peak_table ------------------------------------------------------
peak_table <- readRDS("test-data/minimal_testset_peak_table.RDS")
peak_table <- mutate(peak_table)
# Two identification runs ------------------------------------------------------
wmz_min <- 5;
wmz_max <- 50;
wrt_min <- 1;
wrt_max <- 100;
tolerance_ppm <- 20
min_size_polymer <- 4
diffs <- expandTargetDifferences( c(14.0156, 44.02628), c(1,2))
tictoc::tic()
out1 <- identifyPolymers(peak_table, wmz_min, wmz_max, wrt_min, wrt_max, tolerance_ppm,
min_series_length = min_size_polymer,
search_mode = "targeted",  mz_steps = diffs, step_mode = "increment")
tictoc::toc()
#plotPeakTableInteractive(out1)
tictoc::tic()
out2 <- identifyPolymers(peak_table, wmz_min, wmz_max, wrt_min, wrt_max, tolerance_ppm,
min_series_length = min_size_polymer,
search_mode = "untargeted",  mz_steps = diffs, step_mode = "increment")
tictoc::toc()
#plotPeakTableInteractive(out2)
series_db1 <- sdbCreate(out1, sample_origin = "FLASCH", sample_description = "MSDIAL Processed; subset")
series_db2 <- sdbCreate(out2, sample_origin = "FLASCH", sample_description = "MSDIAL Processed; subset")
summary1 <- sdbSummarize(series_db1, calcMF_tolerance = 200)
summary2 <- sdbSummarize(series_db2, calcMF_tolerance = 200)
db1 <- sdbCreate(out1, sample_origin = "FLASCH", sample_description = "MSDIAL Processed; subset")
exclusion_list <- sdbCheckContained(db1, out2, ppm_tolerance = 1, rt_tolerance = 1)
out3 <- identifyPolymers(peak_table, wmz_min, wmz_max, wrt_min, wrt_max, tolerance_ppm,
min_series_length = min_size_polymer,
search_mode = "targeted",  mz_steps = c(14.0156), step_mode = "increment")
out4 <- identifyPolymers(peak_table, wmz_min, wmz_max, wrt_min, wrt_max, tolerance_ppm,
min_series_length = min_size_polymer,
search_mode = "targeted",  mz_steps = c(28.0313), step_mode = "increment")
sdb <- sdbCreate(out3)
load_all()
sdb <- sdbPush(sdb, out4)
checkAnnotatedTableFormat(new_series)
checkSeriesDBFormat(series_db)
# Overwrites new_series polymer ids to fit with the db. Simple extension of
# the max. Ids are not enforced to be consecutive integers.
db_max_id <- max(series_db$polymer_id)
new_series <- new_series %>%
na.omit(.) %>%
group_by(., polymer_id) %>%
mutate(., polymer_id = cur_group_id() + db_max_id) %>% ungroup()
# Determine push_id from series_db push identifiers. This is a simple
# push index.
push_id <- max(series_db$push_id) + 1L
series_db
checkAnnotatedTableFormat(new_series)
checkSeriesDBFormat(series_db)
# Overwrites new_series polymer ids to fit with the db. Simple extension of
# the max. Ids are not enforced to be consecutive integers.
db_max_id <- max(series_db$polymer_id)
new_series <- new_series %>%
na.omit(.) %>%
group_by(., polymer_id) %>%
mutate(., polymer_id = cur_group_id() + db_max_id) %>% ungroup()
# Determine push_id from series_db push identifiers.
push_id <- max(series_db$push_id) + 1L
# MARKED FOR FIXING <------------------------------------------------------------------------ MARKED FOR FIXING
# Make sure that the behavior introduced here allows for noise or polymer series name additions in scalar and vector
# form, or remove these settings from sdbPush
new_series <- new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description)) %>%
select(., mz, rt, intensity, polymer_id, within_series_id, noise,
polymer_series_name, timestamp, push_id, sample_origin,
sample_description, sample_peak_id)
new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description))
series_db
new_series
sdb <- sdbPush(sdb, out4)
load_all()
sdb <- sdbPush(sdb, out4)
new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description))
new_series
new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description))
# Determine push_id from series_db push identifiers.
push_id <- max(series_db$push_id) + 1L
new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description))
new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description)) %>%
select(., mz, rt, intensity, polymer_id, within_series_id, noise,
polymer_series_name, timestamp, push_id, sample_origin,
sample_description, sample_peak_id)
max_intensities <- new_series %>%
group_by(., polymer_id) %>% # grouping assures a max being selected for each polymer_id
slice_max(intensity, n = 1, with_ties = FALSE) %>%
ungroup() %>% mutate(., max_intensity = TRUE) %>% select(., polymer_id, sample_peak_id, max_intensity)
new_series <- new_series %>%
mutate(timestamp = Sys.time(),
push_id = push_id,
noise = as.logical(NA),
polymer_series_name = as.character(NA),
sample_peak_id = peak_id,
sample_origin = as.character(sample_origin),
sample_description = as.character(sample_description)) %>%
select(., mz, rt, intensity, polymer_id, within_series_id, noise,
polymer_series_name, timestamp, push_id, sample_origin,
sample_description, sample_peak_id)
# Find and add max intensity identifier to new_series
max_intensities <- new_series %>%
group_by(., polymer_id) %>% # grouping assures a max being selected for each polymer_id
slice_max(intensity, n = 1, with_ties = FALSE) %>%
ungroup() %>% mutate(., max_intensity = TRUE) %>% select(., polymer_id, sample_peak_id, max_intensity)
max_intensities
new_series <- full_join(new_series, max_intensities,
by = c("polymer_id", "sample_peak_id")) %>%
mutate(., max_intensity = if_else(is.na(max_intensity), FALSE, max_intensity)) %>%
group_by(., polymer_id) %>%
mutate(., normalized_intensity = intensity / sum(intensity)) %>%
select(., -"intensity") %>%
ungroup(.)
new_series
series_db <- bind_rows(series_db, new_series)
series_db
load_all()
document()
document()
load_all()
document()
load_all()
document()
?options
load_all()
library(xcms)
setwd("~/Projects/2022-may-christoph-r-xcms-course")
setwd("~/Projects/2022-may-christoph-r-xcms-course")
library(xcms)
## clean environment and console to easily track the calculations
rm(list=ls())
cat("\014")
## increase RStudio internal console length
rstudioapi::writePreference("console_max_lines", 10000)
#### Parameters for processing
## Set working directory (directory where the script is saved)
setwd("~/LV_DataScience/")
