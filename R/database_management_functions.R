#' sdbRemovePush
#'
#' Function filters series_db object to not contain any of the push_ids provided (scalar or list/vector of integers).
#'
#' @param series_db A series_db tibble as generated by sdbCreate()
#' @param push_ids A single integer or list/vector of push_id integers to be filtered from series_db.
#'
#' @return Filtered series_db tibble. If filtering removes all rows of series_db, NA will be returned alongside a warning message.
#' @export
#'
sdbRemovePush <- function(series_db, push_ids){
  checkSeriesDBFormat(series_db)
  series_db <- series_db %>% filter(., !(push_id %in% push_ids))
  if(nrow(series_db) == 0){
    print("Warning: No elements left in series_db Returning NA.")
    return(NA)
  }
  return(series_db)
}



#' sdbRemoveHomologue
#'
#' Function filters series_db object to not contain any of the homologue_ids provided (scalar or list/vector of integers).
#'
#' @param series_db A series_db tibble as generated by sdbCreate()
#' @param homologue_ids A single integer or list/vector of homologue_id integers to be filtered from series_db.
#'
#' @return Filtered series_db tibble. If filtering removes all rows of series_db, NA will be returned alongside a warning message.
#'
#' @export
#'
sdbRemoveHomologue <- function(series_db, homologue_ids){
  checkSeriesDBFormat(series_db)
  series_db <- series_db %>% filter(., !(homologue_id %in% homologue_ids))
  if(nrow(series_db) == 0){
    print("Warning: No elements left in series_db Returning NA.")
    return(NA)
  }
  return(series_db)
}



#' sdbLoad
#'
#' Function loads a series_db object from provided path. A series_db format check is performed before returning the read object to alert users to possible mismatch in data structure. Function stopped if wrong format detected. series_db object needs to be saved as .RDS file using sdbSave or saveRDS.
#'
#' @param series_db_path Absolute or relative path from current working directory to a saved series_db file.
#'
#' @return series_db tibble.
#' @export
#'
sdbLoad <- function(series_db_path){
  if (file.exists(series_db_path)){
    series_db <- readRDS(series_db_path)
    checkSeriesDBFormat(series_db)
    return(series_db)
  } else {
    stop(paste("Provided file path:", series_db_path, "not found from current work directory."))
  }
}



#' sdbSave
#'
#' Function saves series_db to file using provided absolute or relative file path as the name. Function performs existence checks to warn user of possible overwriting of existing files using interactive prompt.
#'
#' The interactive prompt can be deactivated using check_exists. See function input parameters.
#'
#' @param series_db A series_db tibble as generated by sdbCreate()
#' @param filename A absolute or relative file path specifying the location and name of the new series_db file. Filename should end on .RDS
#' @param check_exists Toggle for file existence check defaults to TRUE. Set to FALSE for automatic file replacement without warning.
#'
#' @return None. series_db object is written to hard drive.
#' @export
#'
sdbSave <- function(series_db, filename, check_exists = TRUE){
  # Function allows saving series_db to path, if path given is.null -> getwd()
  # Function is a simple wrapper around readRDS, not strictly necessary
  if (file.exists(filename) & check_exists){
    user_input <- readline(prompt = "Warning: filename already exists. Do you wish to overwrite y/n: ")
    stopifnot("File saving aborted. User input must be y or n." = user_input %in% c("y", "n"))
    if (user_input == "y") {
      print("Overwriting existing file.")
      saveRDS(series_db, file = filename)
    } else {
      print("File saving aborted.")
    }
  } else {
    saveRDS(series_db, file = filename)
  }
}



#' sdbRescaleHomologueIds
#'
#' Function changes homologue_ids in series_db to consecutive integers starting from 0 to the number of homologues in series_db. homologue_id ordering is maintained. Utility function designed to have simpler homologue identifiers for plotting if many homologue ids are removed from series_db. Homologue names and noise status remain unchanged.
#'
#' Changing homologue_ids will lead to identifier inconsistencies with any analyses or plots created prior to renaming!
#'
#' @param series_db A series_db tibble as generated by sdbCreate()
#'
#' @return A series_db tibble with homologue ids rescaled to range from 1 to n_homologues.
#' @export
sdbRescaleHomologueIds <- function(series_db){
  # Function changes homologue_id to consecutive integers starting from 0 to the
  # number of homologues. Homologues will be ordered by their current numeric id value.
  warning("Homologue ids are rescaled. If this series database was used before to annotate a peak table, the rescaled homologue identifiers of this database will not match with those annotations anymore.")
  series_db <- series_db %>%
    arrange(., homologue_id) %>%
    group_by(., homologue_id) %>%
    mutate(., homologue_id = cur_group_id())
  return(series_db)
}



#' sdbRenameHomologue
#'
#' Function allows for renaming specific homologue_ids for future reference.
#'
#' @param series_db A series_db tibble as generated by sdbCreate()
#' @param homologue_id_set An integer scalar or list/vector of integer homologue ids to be renamed.
#' @param name_set A character string or list/vector of character strings with names for the homologue_id_set.
#'
#' @return A series_db tibble with updated homologue names.
#' @export
sdbRenameHomologue <- function(series_db, homologue_id_set, name_set){
  stopifnot("The number of provided homologue identifiers and names must be equal." = length(homologue_id_set) == length(name_set))
  stopifnot("Name must be of type character (scalar or list of characters)." = is.character(name_set))
  new_names_tibble <- tibble(homologue_id = homologue_id_set, name = name_set)
  series_db <- left_join(series_db, new_names_tibble, by = "homologue_id") %>%
    mutate(., homologue_series_name = if_else(!(is.na(name)), name, homologue_series_name)) %>%
    select(., -"name")
  return(series_db)
}



#' sdbSetHomologueNoise
#'
#' Function allows to change the noise attribute of a single or set of homologue ids within series_db.
#'
#' If a set of homologue_ids are to get the same noise level please use: rep(TRUE, times = length(homologue_ids)) or rep(FALSE, times = length(homologue_ids)) to guarantee length of noise vector is equal to length of homologue_id vector.
#'
#' @param series_db A series_db tibble as generated by sdbCreate()
#' @param homologue_id_set An integer scalar or list/vector of integer homologue ids to have their noise status changed.
#' @param noise_set An boolean scalar or list/vector of booleans with noise assignments for the homologue_id_set.
#'
#' @return A series_db tibble with updated homologue noise identifiers.
#' @export
sdbSetHomologueNoise <- function(series_db, homologue_id_set, noise_set){
  # Changes homologue_id matches in series_db to specified noise indicator.
  # homologue_id_set and noise_set must be scalars or vectors of the same length.
  # If a set of homologue_ids are to get the same noise level please use: rep(TRUE, times = length(homologue_ids)).
  stopifnot("The number of provided homologue identifiers and noise indicators must be equal." = length(homologue_id_set) == length(name_set))
  stopifnot("Noise must be of type logical (scalar or list of logicals)." = is.logical(noise_set))
  new_noise_tibble <- tibble(homologue_id = homologue_id_set, new_noise = noise_set)
  series_db <- left_join(series_db, new_noise_tibble, by = "homologue_id") %>%
    mutate(., noise = if_else(!(is.na(new_noise)), new_noise, noise)) %>%
    select(., -"new_noise")
  return(series_db)
}



#' sdbPush
#'
#' Function adds homologues from new_series tibble (annotated peak table) to series_db. All new additions will receive their unique push_id and timestamp. No duplicate checking is done here, please use checkContained to make sure that homologues or their constituent peaks to be added are not already contained within series_db.
#'
#' @param series_db A series_db tibble as generated by sdbCreate().
#' @param new_series A annotated peak_table as produced by detectHomologues().
#' @param sample_origin Character string indicating the sample / processing run origin of the identified series in non-standardized form.
#' @param sample_description Character string containing any relevant information about the sample / processing run in non-standardized from.
#'
#' @return series_db A series_db tibble as generated by sdbCreate() with an additional set of homologues added.
#' @export
sdbPush <- function(series_db, new_series, sample_origin = NA, sample_description = NA){
  checkAnnotatedTableFormat(new_series)
  checkSeriesDBFormat(series_db)

  # Overwrites new_series homologue ids to fit with the db. Simple extension of
  # the max. Ids are not enforced to be consecutive integers.
  db_max_id <- max(series_db$homologue_id)
  new_series <- new_series %>%
    na.omit(.) %>%
    group_by(., homologue_id) %>%
    mutate(., homologue_id = cur_group_id() + db_max_id) %>% ungroup()

  # Determine push_id from series_db push identifiers.
  push_id <- max(series_db$push_id) + 1L
  new_series <- new_series %>%
    mutate(timestamp = Sys.time(),
           push_id = push_id,
           noise = as.logical(NA),
           homologue_series_name = as.character(NA),
           sample_peak_id = peak_id,
           sample_origin = as.character(sample_origin),
           sample_description = as.character(sample_description)) %>%
    select(., mz, rt, intensity, homologue_id, within_series_id, noise,
           homologue_series_name, timestamp, push_id, sample_origin,
           sample_description, sample_peak_id)
  # Find and add max intensity identifier to new_series
  max_intensities <- new_series %>%
    group_by(., homologue_id) %>% # grouping assures a max being selected for each homologue_id
    slice_max(intensity, n = 1, with_ties = FALSE) %>%
    ungroup() %>% mutate(., max_intensity = TRUE) %>% select(., homologue_id, sample_peak_id, max_intensity)

  new_series <- full_join(new_series, max_intensities,
                          by = c("homologue_id", "sample_peak_id")) %>%
    mutate(., max_intensity = if_else(is.na(max_intensity), FALSE, max_intensity)) %>%
    group_by(., homologue_id) %>%
    mutate(., normalized_intensity = intensity / sum(intensity)) %>%
    select(., -"intensity") %>%
    ungroup(.)
  series_db <- bind_rows(series_db, new_series)
  return(series_db)
}
